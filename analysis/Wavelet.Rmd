---
title: "Drivers and CH4"
author: "Abby Lewis"
date: "2024-08-22"
output: html_document
---

Methods from Ari's paper and this one https://agupubs.onlinelibrary.wiley.com/doi/full/10.1002/2015JG003054

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
#source("../R/qaqc.R")
target <- read_csv("../processed_data/partitioned_co2.csv") %>%
  rename(TIMESTAMP = DateTime)
met <- read_csv("../processed_data/met_2025_dashboard.csv")
wl <- read_csv("../processed_data/water_level_dashboard.csv")
evi <- read_csv("../processed_data/evi.csv")

df <- target %>%
  mutate(time_join = round_date(TIMESTAMP, "15 minutes"),
         date_join = date(TIMESTAMP)) %>%
  left_join(met %>% rename(time_join = TIMESTAMP)) %>%
  left_join(wl %>% rename(time_join = TIMESTAMP)) %>%
  left_join(evi %>% rename(date_join = Date)) %>%
  filter(CH4 > -0.1,
         !is.na(TIMESTAMP)) %>%
  mutate(CH4_raised = CH4-min(CH4, na.rm = T)+0.05,
         #CH4 = log(CH4_raised),
         CH4 = CH4_raised
         )

library(data.table)

setDT(df)
df[, TIMESTAMP := as.POSIXct(TIMESTAMP)]

make_grid <- function(g) {
  data.table(
    TIMESTAMP = seq(min(g$TIMESTAMP), max(g$TIMESTAMP), by = "130 min"),
    MIU_VALVE = g$MIU_VALVE[1]
  )
}

grid <- df[, make_grid(.SD), by = MIU_VALVE]

setkey(grid, MIU_VALVE, TIMESTAMP)
setkey(df, MIU_VALVE, TIMESTAMP)

ch4 <- df[grid, roll = "nearest"]

#mean_of_all <- ch4 %>%
#  group_by(TIMESTAMP) %>%
#  summarise(across(where(is.numeric), mean, na.rm = TRUE)) %>%
#  mutate(MIU_VALVE = "mean")
#
#median_of_all <- ch4 %>%
#  group_by(TIMESTAMP) %>%
#  summarise(across(where(is.numeric), median, na.rm = TRUE)) %>%
#  mutate(MIU_VALVE = "median")
#
#ch4 <- ch4 %>%
#  full_join(mean_of_all) %>%
#  full_join(median_of_all)
#
chamber_levels2 = c("Ch. 1 (+0 ºC)", "Ch. 2 (+0 ºC)", "Ch. 3 (+0.75 ºC)", 
                    "Ch. 4 (+1.5 ºC)", "Ch. 5 (+2.25 ºC)", "Ch. 6 (+2.25 ºC)", 
                    "Ch. 7 (+3.0 ºC)", "Ch. 8 (+3.75 ºC)", "Ch. 9 (+3.75 ºC)",
                   "Ch. 10 (+4.5 ºC)", "Ch. 11 (+5.25 ºC)", "Ch. 12 (+6.0 ºC)")

color.gradient=c('blue4','blue3','turquoise4','lightseagreen',
                 'mediumseagreen','limegreen','yellowgreen','yellow2',
                 'darkgoldenrod2','darkorange2','orangered1','red2')

ch4 %>%
  ggplot(aes(x = TIMESTAMP, y = CH4))+
  geom_point()+
  facet_wrap(~MIU_VALVE)
```

Then, we used Mutual Information (I) to find the relative importance of each predictor variable and identify both synchronous and asynchronous interactions (Ruddell et al., 2013). Mutual Information (I) measures the amount of information shared by two variables, X and Y, or the reduction in uncertainty of one variable given the knowledge of the other variable (Fraser & Swinney, 1986). The degree of mutual information between X and Y is increased by adding a time lag (positive or negative) in series Y relative to X, thereby allowing the identification of both synchronous and asynchronous interactions. 

Using the ProcessNetwork Software (v1.5, Ruddell et al., 2008) and the Wavelet Methods for Time Series Analysis (WMTSA) toolkit (Cornish et al., 2003), we decomposed gap-filled CH4 flux and explanatory variables in four general timescales of variation: hourly (1-2 hours), diel (4 hours – 1.3 days), multiday (2.7 – 21.3 days) and seasonal (42.7 – 341 days). These timescales of variation represented short-term perturbations such as wind gusts or overpassing clouds, day-night changes in meteorological variables and tidal fluctuations, neap-spring tidal cycles, and seasonal courses of solar movement and vegetation phenology, respectively. Wavelet decomposition was performed on gap-filled, half-hourly data using the maximal overlap discrete wavelet transform (MODWT), summing the detail over adjacent scales to yield the latter four time-scales of variation (details in (Sturtevant et al., 2016). Wavelet decomposed data were then used to compute the mutual information between CH4 fluxes and biophysical variables within each timescale over a range of time lags (from half a day at the diel scale to 60 days at the seasonal scale). Original gaps in the reconstructed time series were reintroduced before mutual information calculation for all except the seasonal analysis following (Knox et al., 2021). Results were interpreted using the relative mutual information (IR) metric, a normalized measure of the statistical dependence of CH4 flux on a range of predictor variables, with larger values indicating higher dependence. To determine the relative importance of each predictor variable, we ranked the normalized IR values across sites, and we did that within each timescale of interest. In this study, we followed the methods described by Knox et al. 2021 (i.e., 10 bins and 50 random reshufflings to calculate significance thresholds at each lag) and focused on results for the predictors of diel, multiday, and seasonal timescales.

Wavelet

```{r}
library(waveslim)

parse_time <- function(s_list){
  out <- numeric(length(s_list))
  for(i in 1:length(s_list)){
    if(s_list[i] < 1.5*86400){
      out[i] <- paste(round(s_list[i]/60/60), "hours")
    } else {
      out[i] <- paste(round(s_list[i]/60/60/24), "days")
    }
  }
  return(out)
}

analyze_wavelets <- function(ch4, treatment, var_name, timestep_s) {
  #Format data (dealing with irregularly spaced data)
  test_data <- ch4 %>%
    filter(MIU_VALVE == treatment) %>%
    filter(!is.na(!!sym(var_name)))
  
  #Run wavelet transformation
  data <- zoo::na.approx(test_data[[var_name]])
  wavelet <- waveslim::modwt(data, "la8", n.levels = 11)
  
  meshed <- data.frame(TIMESTAMP = test_data$TIMESTAMP,
                       data,
                       l_1 = wavelet[[1]],
                       l_2 = wavelet[[2]],
                       l_3 = wavelet[[3]],
                       l_4 = wavelet[[4]],
                       l_5 = wavelet[[5]],
                       l_6 = wavelet[[6]],
                       l_7 = wavelet[[7]],
                       l_8 = wavelet[[8]],
                       l_9 = wavelet[[9]],
                       l_10 = wavelet[[10]],
                       l_11 = wavelet[[11]]) %>%
    pivot_longer(cols = -c(data, TIMESTAMP)) %>%
    mutate(name = as.numeric(sub("l_", "", name)),
           name = factor(name, 
                         levels = 1:11,
                         labels = parse_time(2^(0:10)*timestep_s)
                           ))
  
  df <- meshed %>% 
    mutate(MIU_VALVE = treatment,
           var_name = var_name)
  
  return(df)
}

#Apply across all treatments and sites
grid <- ch4 %>%
  pivot_longer(cols = c(CH4, AirTC_Avg, Depth_cm), #NOTE: I've also tried EVI and PAR but they don't add much
               names_to = "var_name", values_to = "value")

double_map <- function(treatment, ch4, var_name, timestep_s){
  dfs <- map(unique(ch4$MIU_VALVE), 
             analyze_wavelets, 
             ch4 = ch4, 
             var_name = var_name,
             timestep_s = timestep_s) %>%
    bind_rows()
}

dfs <- map(unique(grid$var_name), 
           double_map, 
           ch4 = ch4, 
           treatment = unique(ch4$MIU_VALVE),
           timestep_s = 610*12) %>%
  bind_rows()

#Plot
pct_var <- dfs %>%
  group_by(name, MIU_VALVE, var_name) %>%
  summarize(var = var(value)) %>%
  group_by(MIU_VALVE, var_name) %>%
  mutate(tot_var = sum(var),
         MIU_VALVE = ifelse(var_name == "CH4", MIU_VALVE, NA),
         MIU_VALVE = factor(MIU_VALVE,
                            levels = 1:12,
                            labels = chamber_levels2),
         var_name = factor(var_name,
                          levels = c("AirTC_Avg",
                                     "Depth_cm",
                                     "CH4"),
                          labels = c("Air~temperature",
                                     "Water~depth",
                                     "CH[4]"))) %>%
  group_by(MIU_VALVE, name, var_name) %>%
  summarize(var = mean(var),
            tot_var = mean(tot_var)) %>%
  ungroup() %>%
  ggplot(aes(x = name, y = var/tot_var * 100, 
             color = MIU_VALVE, group = MIU_VALVE)) +
  geom_point() +
  geom_line() +
  labs(x = "Wavelet scale",
       y = "Percentage of total variance") +
  scale_color_manual(name = "Chamber", 
                     values = color.gradient,
                     na.value = "black") +
  egg::theme_article()+
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        panel.grid.major = element_line(color = "grey93", linewidth = 0.5),
        panel.grid.minor = element_line(color = "grey95", linewidth = 0.25),
        plot.background = element_rect(fill = "white"))+
  facet_wrap(~var_name, labeller = "label_parsed")
pct_var
```

Mutual Information

```{r}
library(DescTools)

N_BINS = 11

#Make functions to calculate key metrics
entropy <- function(target) {
  freq <- table(target)/length(target)
  # vectorize
  vec <- as.data.frame(freq)[,2]
  #compute entropy
  -sum(vec * log2(vec))
}

bin <- function(x, n_breaks) {
  highest <- quantile(x, 0.99)
  lowest <- quantile(x, 0.01)
  findInterval(x, seq(lowest, highest, length.out = n_breaks))
}

#Group wavelet scales into interpretable bins
discrete_scales <- dfs %>%
  #mutate(grouped_scale = ifelse(grepl("hour", name), 
  #                              "Sub-daily",
  #                              ifelse(as.numeric(sub(" days", "", name)) < 30,
  #                                     "Multiday", "Seasonal"))) %>%
  mutate(#name = as.character(name),
         grouped_scale = name,
         #grouped_scale = case_match(name,
         #                           "2 hours"~"2 hours",
         #                           "8 hours"~"8 hours",
         #                           "3 days"~"3 days",
         #                           "87 days"~"87 days")
         ) %>%
  filter(!is.na(grouped_scale)) %>%
  group_by(grouped_scale, MIU_VALVE, TIMESTAMP, var_name) %>%
  summarize(value = sum(value)) %>%
  pivot_wider(names_from = var_name, values_from = value) 

#Separate explanatory variables
discrete_scales_exp <- discrete_scales %>%
  dplyr::select(-c(CH4)) %>%
  pivot_longer(cols = -c(grouped_scale, MIU_VALVE, TIMESTAMP), 
               names_to = "exp_var", values_to = "exp_var_value") %>%
  filter(!is.na(exp_var_value)) %>%
  rename(grouped_scale_exp = grouped_scale)

#Calculate mutual information
mut_infs <- discrete_scales %>%
  dplyr::select(c(grouped_scale, MIU_VALVE, TIMESTAMP, CH4)) %>%
  left_join(discrete_scales_exp, relationship =
              "many-to-many") %>%
  filter(!is.na(exp_var_value),
         !is.na(CH4)) %>%
  group_by(MIU_VALVE, grouped_scale, exp_var, grouped_scale_exp) %>%
  summarize(entropy_y = entropy(bin(CH4, N_BINS)),
            mut_inf = MutInf(bin(exp_var_value, N_BINS), bin(CH4, N_BINS))/entropy_y)

#Plot
mut_infs %>%
  ungroup() %>%
  filter(grouped_scale == grouped_scale_exp,
         !exp_var == "evi_predicted") %>%
  mutate(MIU_VALVE = factor(MIU_VALVE,
                            levels = 1:12,
                            labels = chamber_levels2),
         mut_inf = ifelse(exp_var == "evi_predicted" & 
                            grepl("hours", grouped_scale), NA,
                          mut_inf),
         exp_var = factor(exp_var,
                          levels = c("AirTC_Avg",
                                     "Depth_cm"),
                          labels = c("Air temperature",
                                     "Water depth"))) %>%
  ggplot(aes(y = mut_inf, x = grouped_scale, 
             color = exp_var, group = exp_var)) +
  geom_point(aes(shape = exp_var)) + 
  geom_line()+
  facet_wrap(~MIU_VALVE) +
  xlab("Wavelet scale of variation") +
  ylab("Relative mutual information") +
  egg::theme_article()+
  scale_color_manual(values = c("Air temperature" = "#E76D66", 
                                "Water depth" = "#2176AB", 
                                "evi_predicted" = "#354C2F"),
                     name = "Explanatory variable") +
  scale_shape_discrete(name = "Explanatory variable") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        panel.grid.major = element_line(color = "grey93", linewidth = 0.5),
        panel.grid.minor = element_line(color = "grey95", linewidth = 0.25))

simple_mut_inf_plot <- mut_infs %>%
  ungroup() %>%
  filter(grouped_scale == grouped_scale_exp,
         !exp_var == "evi_predicted") %>%
  mutate(MIU_VALVE = factor(MIU_VALVE,
                            levels = 1:12,
                            labels = chamber_levels2),
         mut_inf = ifelse(exp_var == "evi_predicted" & 
                            grepl("hours", grouped_scale), NA,
                          mut_inf),
         exp_var = factor(exp_var,
                          levels = c("AirTC_Avg",
                                     "Depth_cm"),
                          labels = c("Air temperature",
                                     "Water depth"))) %>%
  ggplot(aes(y = mut_inf, x = grouped_scale, 
             color = MIU_VALVE, group = MIU_VALVE)) +
  geom_point() + 
  geom_line()+
  facet_wrap(~exp_var) +
  xlab("Wavelet scale of variation") +
  ylab("Relative mutual information") +
  egg::theme_article()+
  scale_color_manual(name = "Chamber", values = color.gradient)+
  scale_shape_discrete(name = "Explanatory variable") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        panel.grid.major = element_line(color = "grey93", linewidth = 0.5),
        panel.grid.minor = element_line(color = "grey95", linewidth = 0.25),
        plot.background = element_rect(fill = "white"))

simple_mut_inf_plot
ggsave(simple_mut_inf_plot, filename = "../figures/mut_inf_simple.png", width = 6, height = 3)
ggsave(pct_var+
         theme(axis.text.x = element_text(size = 8)), 
       filename = "../figures/pct_var_wavelet.png", width = 7, height = 3.5)

ggpubr::ggarrange(pct_var,
          simple_mut_inf_plot,
          nrow = 2, ncol = 1, align = "v", heights = c(1, 1))
```

Random forest
- I don't like this approach. Doing a RF with the seasonal timescale is super suspect

```{r}
library(ranger)

# Storage for results
rf_results <- data.frame()
rf_importance <- data.frame()

# Unique scales and MIU_VALVE
scales <- unique(discrete_scales$grouped_scale)
chambers <- unique(discrete_scales$MIU_VALVE)

# Set number of CV folds
n_folds <- 5
set.seed(123) # reproducible random folds

# Loop over MIU_VALVE
for (chamber in chambers) {
  cat("Processing MIU_VALVE:", chamber, "\n")
  
  df_valve <- discrete_scales %>% filter(MIU_VALVE == chamber) %>% drop_na(CH4)
  
  # Loop over scales
  for (scale_name in scales) {
    
    df_scale <- df_valve %>% filter(grouped_scale == scale_name)
    
    if (nrow(df_scale) < n_folds) {
      cat("  Skipping scale", scale_name, "- not enough data\n")
      next
    }
    
    # Assign random folds
    df_scale$fold <- sample(1:n_folds, nrow(df_scale), replace = TRUE)
    
    # Loop over folds
    for (f in 1:n_folds) {
      
      train <- df_scale %>% filter(fold != f)
      test  <- df_scale %>% filter(fold == f)
      
      # Train RF
      rf <- ranger(
        CH4 ~ AirTC_Avg + Depth_cm,
        data = train,
        num.trees = 500,
        importance = "permutation"
      )
      
      preds <- predict(rf, data = test)$predictions
      
      plot(preds, test$CH4)
      
      # Compute metrics
      rmse <- sqrt(mean((test$CH4 - preds)^2))
      rsq  <- cor(test$CH4, preds)^2
      
      rf_results <- rbind(rf_results,
                          data.frame(
                            MIU_VALVE = chamber,
                            scale = scale_name,
                            fold = f,
                            rmse = rmse,
                            rsq = rsq
                          ))
      
      # Variable importance (same for all folds in this scale)
      imp <- data.frame(
        MIU_VALVE = chamber,
        scale = scale_name,
        variable = names(rf$variable.importance),
        importance = rf$variable.importance
      )
      
      rf_importance <- rbind(rf_importance, imp)
      
    } # end fold loop
    
  } # end scale loop
  
} # end MIU_VALVE loop

# Summarize R² and RMSE
rf_results_summary <- rf_results %>%
  group_by(MIU_VALVE, scale) %>%
  summarize(mean_rsq = mean(rsq),
            sd_rsq = sd(rsq),
            mean_rmse = mean(rmse),
            sd_rmse = sd(rmse),
            .groups = "drop")

# Plot R2 by scale for all chambers
rf_results_summary %>%
  mutate(MIU_VALVE = factor(MIU_VALVE,
                            levels = 1:12,
                            labels = chamber_levels2)) %>%
  ggplot(aes(x = scale, y = mean_rsq, color = MIU_VALVE)) +
  geom_point() +
  geom_line() +
  geom_errorbar(aes(ymin = mean_rsq - sd_rsq, ymax = mean_rsq + sd_rsq), width = 0.2) +
  theme_bw() +
  ylab("Cross-validated R²") +
  xlab("Timescale") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))+
  scale_color_manual(name = "Site", values = color.gradient)

# Variable importance averaged over folds
rf_importance_summary <- rf_importance %>%
  group_by(MIU_VALVE, scale, variable) %>%
  summarize(median_importance = median(importance), .groups = "drop")

rf_importance_summary %>%
  mutate(MIU_VALVE = factor(MIU_VALVE,
                            levels = 1:12,
                            labels = chamber_levels2)) %>%
  ggplot(aes(x = variable, y = median_importance, color = MIU_VALVE)) +
  geom_point()+
  facet_wrap(~scale) +
  coord_flip() +
  theme_bw() +
  ylab("Permutation importance") +
  xlab("Predictor variable")+
  scale_color_manual(name = "Site", values = color.gradient)

```









With lags

```{r}
#Separate explanatory variables
discrete_scales_exp <- discrete_scales %>%
  dplyr::select(-CH4, -NEE) %>%
  pivot_longer(cols = -c(grouped_scale, MIU_VALVE, TIMESTAMP), 
               names_to = "exp_var", values_to = "exp_var_value") %>%
  filter(!is.na(exp_var_value)) %>%
  rename(grouped_scale_exp = grouped_scale)

fill_lags <- function(all_lags, lag) {
  if(lag == 0 | nrow(all_lags) == 0) {
    return(all_lags %>% filter(is.na(MIU_VALVE))) #empty
  }
  if(lag < 0){
    filled_lags <- all_lags %>%
      mutate(exp_var_value_lag = lag(exp_var_value, abs(lag))) %>%
      mutate(lag = lag)
  }
  if(lag > 0){
    filled_lags <- all_lags %>%
      mutate(exp_var_value_lag = lead(exp_var_value, lag)) %>%
      mutate(lag = lag)
  }
  return(filled_lags)
}

#library(furrr)
#plan(multisession)
output <- pmap(list(-200:0), 
              ~fill_lags(all_lags = discrete_scales_exp %>%
                           group_by(grouped_scale_exp, 
                                    MIU_VALVE, 
                                    exp_var) %>%
                           arrange(TIMESTAMP),
                         .x),
              .progress = T) %>%
  bind_rows()

#Calculate mutual information
lagged_mut_infs <- discrete_scales %>%
  dplyr::select(c(grouped_scale, MIU_VALVE, TIMESTAMP, CH4)) %>%
  left_join(output, by = c("MIU_VALVE", "TIMESTAMP")) %>%
  filter(!is.na(exp_var_value_lag),
         !is.na(CH4)) %>%
  group_by(MIU_VALVE, grouped_scale, exp_var, grouped_scale_exp, lag) %>%
  summarize(entropy_y = entropy(bin(CH4, 9)),
            mut_inf = MutInf(bin(exp_var_value, 9), bin(CH4, 9))/entropy_y) 

best_lagged_mut_infs <- lagged_mut_infs %>%
  group_by(MIU_VALVE, grouped_scale, exp_var, grouped_scale_exp) %>%
  filter(mut_inf == max(mut_inf, na.rm = T))

#Plot
for(site in unique(discrete_scales$MIU_VALVE)){
  plot <- best_lagged_mut_infs %>%
    filter(MIU_VALVE == site) %>%
    ggplot(aes(x = mut_inf, y = exp_var, fill = lag)) +
    geom_col() + 
    geom_col(data = mut_infs %>% filter(MIU_VALVE == site), fill = "black")+
    facet_grid(cols = vars(grouped_scale), rows = vars(grouped_scale_exp)) +
    ylab("Explanatory variable") +
    xlab("Relative mutual information") +
    scale_fill_distiller(palette = "RdYlBu", direction = -1) +
    ggtitle(site)
  print(plot)
}

for(scale in unique(discrete_scales$grouped_scale)){
  plot <- lagged_mut_infs %>%
    filter(lag <= 0, lag >=-100) %>%
    mutate(MIU_VALVE = factor(MIU_VALVE,
                                    levels = chamber_levels2),
         grouped_scale = paste0(grouped_scale, " (CH4)")) %>%
    filter(grouped_scale_exp == scale) %>%
    ggplot(aes(x = lag, y = mut_inf, color = MIU_VALVE))+
    geom_line()+
    scale_color_viridis_d()+
    facet_grid(rows = vars(exp_var), cols = vars(grouped_scale))+
    ggtitle(scale)
  print(plot)
}
```

Ari:
Quantile regressions were fitted for the 0.1, 0.5, and 0.9 quantiles of CH4 fluxes using the nlrq() function within the R package ‘quantreg’ (Koenker, 2023) due to the observed non-linear relationships between CH4 fluxes and the tested predictor variables. The slopes of the fitted conditional quantile regressions were used to estimate the predictor level required to decrease CH4 fluxes by half, based on an exponential decay relationship (i.e., X1/2 = ln(2)/slope). Subsequently, threshold values were estimated as 7 times X1/2, representing a 99% reduction of CH4 fluxes through interactions with increasing predictor levels. We calculated these thresholds for the 50th and 90th percentiles of the conditional distribution of CH4 fluxes, representing the predictor thresholds below which the 50% and 90% of the highest CH4 fluxes occur, respectively.

Partial associations:
https://agupubs.onlinelibrary.wiley.com/doi/full/10.1002/2013WR013845
